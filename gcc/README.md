### 1，预处理、编译、汇编、链接

可执行文件的生成过程：

* 预处理

  主要将源代码文件中以#开始的预编译指令展开，即包含的文件插入到该预编译指令的位置。同时删除所有的注释。展开所有的宏定义。

  ~~~shell
  gcc -E hello.c -o hello.i
  ~~~

* 编译

  把预处理文件进行一系列的词法分析，语法分析，语义分析优化后产生相应的汇编文件。

  ~~~shell
  gcc -S hello.i -o hello.s
  ~~~

* 汇编

  将汇编文件代码转变为机器可执行的指令，根据汇编指令和机器指令的对照表进行翻译。

  ~~~shell
  gcc -c hello.c -o hello.o
  as hello.s -o hello.o
  ~~~

* 链接

  装载必要文件。定义在其他模块的全局变量和函数在最终运行时的绝对地址，都要在最终链接的时候才能确定。所以编译器将源代码文件编译成一个未链接的目标文件，然后由连接器最终将这些的文件进行链接。

### 2，为什么需要链接

* 符号的概念

  它表示一个地址，这个地址可能是一段子程序（函数）的起始地址，也可能是一个变量的起始地址。

  ~~~shell
  jmp foo
  ~~~

  把函数foo 的函数地址赋予符号 foo，语句的含义是直接的跳转到该函数处执行代码。不管foo 之前或是之后插入多少的代码，导致foo 地址的变化，汇编器在每次汇编程序的时候会重新的极端foo 这个符号的地址，然后所有引用到foo 这个地址的指令修正到正确的指令地址。

* 链接的概念

  一个程序往往由多个模块组成，这些模块如何的组合，形成一个单一程序，关键点在于各模块之间的通信问题。解决的方式为模块间的符号引用。引用的过程即为链接的过程。每个模块独立的编译，然后按照需要将它们按照需要“拼接”起来。

* 库的概念

  将模块生成的目标文件，进行打包，就形成了库。库即目标文件有序的组织，进行快速的查找。

### 3，目标文件格式

linux 中有ELF（Executable Linkable Format）和 win 的PE （Portable Executable）。ELF 文件标准把系统中采用ELF 格式的文件分为四类：

* 可重定位文件（reloactable file）代表为linux 的 .o 文件。win 下的 xx.obj

​	其包含了代码和数据，可以被用来连接成为可自行文件或是共享目标文件，静态链接库也为此类。

* 可执行文件（executable file）linux 下没有后缀，win 下的exe。

  其包含了可以直接执行的程序，代表即为ELF 可执行文件，一般没有扩展名。

* 贡献目标文件（shared object file）linux 中的xx.so win下的xx.dll

  其包含了代码和数据，可以在两种情况下使用

  * 连接器可以使用这种文件跟其他的可重定位文件和共享文件链接，产生新的目标文件。
  * 动态链接器可以将这几种共享目标文件与可执行文件结合，作为进程影响的一部分来运行。

* 核心转储文件 （core dump file）

  当进程意外终止时，系统可以将该进程的地址空间的内容以及终止时的一些其他信息转储到核心转储文件。

  PS：使用file 命令可进行查看。

### 4，静态链接

* 基本概念

  静态库可以简单的堪称一组目标文件的集合，即很多目标文件经过压缩打包后，形成的一个文件。通常使用ar 压缩程序将这些目标文件压缩到一起并且对其进行编号和索引，以便查找和检索。

  可以使用以下命令查看

  ~~~shell
  ar -t libc.a 
  ~~~

  查找某个符号在哪个目标文件中可以使用：比如查看print 函数

  ~~~shell
  objdump -t libc.a | grep print 
  ~~~

  静态库的缺点是：浪费内存和磁盘空间，模块更新困难。

### 5，动态链接

* 基本的概念

一般把程序的模块相互分割开来，形成独立文件，而不再将它们静态的链接起来。即不对那些组成程序的目标文件进行链接，等到程序要运行时，才进行链接，把链接的过程推迟到运行时，再进行。动态链接的方式使得开发过程中各个模块更加的独立，耦合度更小，便于不同的开发者之间独立的进行开发和测试。

~~~shell
gcc -fPIC -shared -o lib.so lib.c
~~~

* 动态链接的机制

  当模块p1.c 被编译成 p1.o 时，编译器还不知道foo() 函数的地址。当编译器将p1.0 链接成可执行文件时，必须要确定p1.c 中所引用的foo() 函数的性质。如果函数foo() 时定义在其他静态目标模块中的函数，那连接器会按照静态链接的规则，将p1.o 中的foo() 地址进行重定位，如果foo() 是一个定义在某个动态对象中的函数，那连接器会将这个符号的应用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时在进行。那lib.so 就是让连接器知晓foo 为动态符号的输入文件。

* 基址重定位 -shared

​		在链接时候，对所有绝对地址的引用进行重定位，叫做链接时重定位，而把这一步推迟到装载时在进行叫做装载时重定位，也叫基址		重置。命令为gcc 中 的 -share 参数。

* 地址无关代码 -fPIC

  装载时重定位时解决动态模块中绝对地址引用的方法，但它缺点是指令部分无法在多个进程之间共享。我们希望程序模块中共享的指令部分，在装载时，不需要应为装载地址的改变而改变。

  方案为，指令中那些需要被修改的部分，被分离出来，跟数据部分放在一起。这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本，即地址无关代码 （PIC position independent code）

* 延迟绑定 PLT

​	在程序运行过程中，可能很多程序中的函数在程序运行完毕后，都不会被用到，如果一开始就把所有函数都链接好，是一种资源的浪费，所以ELF 采用了一种延迟绑定的做法 lazy binding 即当函数第一次被调用时候才进行绑定。

### 6，共享版本命名

* 命名规则

  ~~~shell
  libname.so.x.y.z
  ~~~

  其中 x：主版本号 y：次版本号 z：发布版本号

  * 主版本号

    表示库的重大升级，不同的版本号之间的库是不兼容的。

  * 次版本号

    表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。在主版本号相同的情况下，高的次版本号的库向下兼容低的次版本号的库。

  * 发布版本

    表示库的一些错误的修正，性能的改进等，并不填加任何的新接口，也不对接口进行更改。

* SO-NAME 动态库名字

  共享库的主版本号和次版本号决定了一个共享库的接口， linux中，普遍采用一种SO-NAME 的命名机制来记录共享库的依赖关系。每个的共享库都有一个SO-NAME 即为共享库的文件名去掉次版本号和发布版本号。系统会为每个共享库在它的共享目录创建一个跟SO-NAME 相同并且只想它的软连接。

  SO-NAME 为名字的软连接会指向目录中主版本号相同，次版本和发布版本号最新的共享库。

### 7， 共享路径

* linux 中的路径遵循FHS 标准（File Hierarchy Standard）

  * /lib 目录

    存放系统最关键和基础的共享库。如动态连接器，C语言运行库等。

  * /usr/lib 

    非系统运行时所需要的关键性共享库。主要是一些开发时用到的共享库。这些共享库，一般不会被用户的程序或是shell 脚本直接使用到。该目录下还包含了开发时可能会用到的静态库，目标文件等。

  * /usr/local/lib 

    主要一些第三方的应用程序的库。比如Python 解释器。与他相关的共享库可能放到 /usr/local/lib/python 目录下，而可执行文件被放到/usr/local/bin 下。推荐第三方的程序应该默认的安装到 /usr/local/lib 下。

* LD_LIBRARY_PARH  环境变量

  ~~~shell
  export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/new_path"
  ~~~

  动态连接器会按照下列顺序依次装载或是查找共享对象。

  * 由环境变量LD_LIBRARY_PARH 指定的路径
  * 由路径缓存文件 /etc/ld.so.cache
  * 默认共享目录，先 /use/lib 在 /lib

### 8，安装

注意在创建docker run的时候一定要加上 - -privileged 否则调试的时候会有权限限制

~~~
sudo apt-get install update
sudo apt-get install build-essential gdb
sudo apt-get install cmake
~~~

可以运行 gdb --version 查看版本。

### 9，gcc 编译

* 查看gcc 版本号

~~~shell
gcc -v
gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
~~~

* 查看cmake 版本

~~~shell
cmake -version
gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
~~~

### 10，g++ 命令行编译指令

* 默认

命令： g++ test.cpp

功能：生成默认为a.exe的文件。

* 命名 -o

命令： g++ test.cpp -o test

功能：生成test.exe的文件。

* 调试 -g

命令： g++ qaq.cpp -o qdq -g

功能：生成用于gdb调试的文件qdq.dSYM。

* 警告 -W -w

命令：g++ qaq.cpp -o qaq -W

功能：显示所有的警告信息

命令：g++ qaq.cpp -o qaq -w

功能：禁止显示所有警告信息

* 优化 -O{num}

命令：g++ qaq.cpp -o qaq -O2

功能：主要有O1,O2,O3,Os，分别优化大小，功能，功能，大小。

* 标准 -std={version}

命令：g++ qaq.cpp -o qaq -O2 -std=c++11

功能：使用标准c++11来编译程序

* 添加pthread 库

命令：g++ qaq.cpp -o qaq -O2 -std=c++11 -lpthread

* gcc makefile -D宏定义 -U取消宏定义

* -rpath 指定动态库搜索目录

`-rpath`选项的语法为`-Wl,-rpath,<path>`，其中`<path>`是动态库的路径。

~~~~shell
g++ -o your_executable your_source_files -Wl,-rpath,/path/to/dynamic/libraries
~~~~

使用`-rpath`选项可以帮助确保在运行时正确地加载所需的动态库，尤其是当动态库不在默认搜索路径中时。

在C++编译选项中，`-rpath`是一个用于指定运行时库搜索路径的选项。它告诉链接器在运行可执行文件时搜索动态库的路径。在CMake中，可以使用`CMAKE_INSTALL_RPATH`变量来设置该选项。该变量用于指定在安装时运行可执行文件时搜索动态库的路径

~~~~shell
set(CMAKE_INSTALL_RPATH "/path/to/dynamic/libraries")
~~~~

* -L 指定动态库目录

-L: 这个选项告诉编译器在链接阶段去哪里寻找所需的库文件。这个选项只影响编译链接过程，并不会改变最终生成的可执行文件的行为。而-rpath: 这个选项用于设置可执行文件在运行时查找动态库的搜索路径，链接器会把 /path/to/library 写入到生成的可执行文件内部，这样当这个可执行文件运行时，系统会按照这个内嵌的路径去查找其依赖的动态库，而不需要依赖于环境变量 LD_LIBRARY_PATH 的设置。

### 11，使用Valgrind 检查内存泄漏

* 安装

~~~shell
apt-get install valgrind
~~~

* 调试命令

~~~bash
valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes  ./filename
~~~

其中

--leak-check=full指的是完全检查内存泄漏，

--show-reachable=yes是显示内存泄漏的地点，

--trace-children=yes是跟入子进程。

### 12，gdb 调试 core

* 1，安装

~~~shell
apt-get install gdb
~~~

* 2，运行命令

~~~shell
gdb [exec file] [ core file]
~~~

* 3，输出发生错误位置

详细的命令 bt

命令bt或where 查看调用栈

使用strace ./test命令可以追踪程序执行

如果断点打不上，可能是编译时未加-g选项

* 4，进入堆栈进行调试

~~~shell
frame 0
~~~

进入栈首函数

* 5，list 显示命令

* 6，print 打印变量值
